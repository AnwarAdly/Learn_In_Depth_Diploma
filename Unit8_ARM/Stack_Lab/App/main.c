/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f103xx.h"
#include "GPIO.h"
#include "EXTI.h"
#include "UART.h"
#include "RCC.h"
#include "SPI.h"
/*
 **************************************************************
 *************************External Symbol *********************
 **************************************************************
 */
extern _estack;
/*
 **************************************************************
 *************************Macro********************************
 **************************************************************
 */
#define OS_SET_PSP(TOP_Add) 	__asm("MOV R0,%[in] \t\n MSR PSP,R0": :[in] "r" (TOP_Add))
#define OS_Switch_SP_PSP		__asm("MRS R0,CONTROL \t\n ORR R0,R0,#0x2 \t\n MSR CONTROL,R0")
#define OS_Switch_SP_MSP		__asm("MRS R0,CONTROL \t\n AND R0,R0,#0x5 \t\n MSR CONTROL,R0")
#define OS_Generate_Interrupt   __asm("SVC #0x3")

#define CPU_Access_Level_Unprivileged() 	{ __asm("MRS R3,CONTROL"); \
											  __asm("ORR R3,R3,#0x01"); \
											  __asm("MSR CONTROL,R3"); \
                                             }

#define CPU_Access_Level_Privileged()        {__asm("MRS R3,CONTROL"); \
											  __asm("LSR R3,R3,#0x01"); \
											  __asm("LSL R3,R3,#0x01"); \
											  __asm("MSR CONTROL,R3"); \
											 }
#define TaskA_Size 				100
#define TaskB_Size 				100
/*
 **************************************************************
 *************************Global Variable **********************
 **************************************************************
 */
uint32_t _S_MSP=&_estack;
uint32_t _E_MSP;
//Stack pointer task A
uint32_t _S_PSP_TA;
uint32_t _E_PSP_TA;
//Stack pointer task B
uint32_t _S_PSP_TB;
uint32_t _E_PSP_TB;
//flag
uint8_t Flag_Task_A=0;
uint8_t Flag_Task_B=0;
uint8_t Flag=0;
/*
 **************************************************************
 *************************Init Functions **********************
 **************************************************************
 */
void Clock_INIT(void)
{
    //set on the clock for PORTA
    RCC_GPIOA_CLK_EN();
    //set on the clock for PORTB
    RCC_GPIOB_CLK_EN();

}
/*
 **************************************************************
 *************************ISR *********************************
 **************************************************************
 */
void SVC_Handler (void)
{
	CPU_Access_Level_Privileged();
}

void EXTI_9 (void)
{
	if(Flag==0)
	{
		Flag_Task_A=1;
		Flag=1;
	}
	else if(Flag==1)
	{
		Flag_Task_B=1;
		Flag=0;
	}
}
/*
 **************************************************************
 *************************Tasks********************************
 **************************************************************
 */
uint8_t Task_A(uint8_t x,uint8_t y)
{
	uint8_t sum=x+y;
	return sum;
}

uint8_t Task_B(uint8_t x,uint8_t y)
{
	uint8_t sub=x-y;
	return sub;
}
/*
 **************************************************************
 *************************OS***********************************
 **************************************************************
 */
void main_os(void)
{
	//init main stack pointer
	_E_MSP=_S_MSP-512;
	//init PSP Task A
	_S_PSP_TA=_E_MSP-8;
	_E_PSP_TA=_S_PSP_TA-TaskA_Size;
	//init PSP Task B
	_S_PSP_TB=_E_PSP_TA-8;
	_E_PSP_TB=_S_PSP_TB-TaskB_Size;
	while(1)
	{
		if(Flag_Task_A==1)
		{
			uint8_t sum;
			Flag_Task_A=0;
			//set PSP
			OS_SET_PSP(_S_PSP_TA);
			//switch to PSP
			OS_Switch_SP_PSP;
			// switch to unprivileged mode
			CPU_Access_Level_Unprivileged();
			sum=Task_A(5, 10);
			//Generate Interrupt to switch to privileged mode
			OS_Generate_Interrupt;
			//set MSP
			OS_Switch_SP_MSP;
		}
		else if(Flag_Task_B==1)
		{
			uint8_t sub;
			Flag_Task_B=0;
			//set PSP
			OS_SET_PSP(_S_PSP_TB);
			//switch to PSP
			OS_Switch_SP_PSP;
			// switch to unprivileged mode
			CPU_Access_Level_Unprivileged();
			sub=Task_B(50, 10);
			//Generate Interrupt to switch to privileged mode
			OS_Generate_Interrupt;
			//set MSP
			OS_Switch_SP_MSP;
		}
	}
}
/*
 **************************************************************
 *************************Main *********************************
 **************************************************************
 */
int main(void)
{
	Clock_INIT();

	EXTI_Config_t Config;
	Config.EXTI_Pin = EXTI9PB9;
	Config.Trigger_Case = EXTI_Trigger_Rising;
	Config.P_IRQ_Callback = EXTI_9;
	Config.IRQ_EN = EXTI_IRQ_ENABLE ;
	MCAL_EXTI_GPIO_init(&Config);
	main_os();
	while (1)
	{

	}
}
